const i18n = {
  en: {
    status: {
      success: "âœ… Success",
      partial: "âš ï¸ Partial Success",
      failed: "âŒ Failed",
      error: "ğŸ”¥ System Error",
    },
    titles: {
      checkin_results: "Check-in Results (Users: ${count})",
      plugin_info: "ğŸ”Œ Plugin Info",
      execution_time: "â±ï¸ Execution Time",
      error_details: "Error Details",
      retry_advice: "Troubleshooting Advice",
    },
    messages: {
      already_claimed: "Already claimed",
      cookie_expired: "Cookie expired",
      activity_ended: "Event has ended",
    },
    info: {
      plugin_name: "**Name**: ${name}",
      plugin_version: "**Version**: ${version}",
      plugin_date: "**Last Update**: ${date}",
      plugin_author: "**Author**: ${author}",
      plugin_contact: "**Contact**: ${contact}",
    },
  },
  "zh-cn": {
    status: {
      success: "âœ… ç­¾åˆ°æˆåŠŸ",
      partial: "âš ï¸ éƒ¨åˆ†æˆåŠŸ",
      failed: "âŒ ç­¾åˆ°å¤±è´¥",
      error: "ğŸ”¥ ç³»ç»Ÿé”™è¯¯",
    },
    titles: {
      checkin_results: "ç­¾åˆ°ç»“æœ (ç”¨æˆ·æ•°: ${count})",
      plugin_info: "ğŸ”Œ æ’ä»¶ä¿¡æ¯",
      execution_time: "â±ï¸ æ‰§è¡Œè€—æ—¶",
      error_details: "é”™è¯¯è¯¦æƒ…",
      retry_advice: "æ•…éšœæ’æŸ¥å»ºè®®",
    },
    messages: {
      already_claimed: "é‡å¤ç­¾åˆ°",
      cookie_expired: "Cookie å¤±æ•ˆ",
      activity_ended: "æ´»åŠ¨å·²ç»“æŸ",
    },
    info: {
      plugin_name: "**æ’ä»¶åç§°**: ${name}",
      plugin_version: "**æ’ä»¶ç‰ˆæœ¬**: ${version}",
      plugin_date: "**æœ€åæ›´æ–°æ—¥æœŸ**: ${date}",
      plugin_author: "**æ’ä»¶ä½œè€…**: ${author}",
      plugin_contact: "**è”ç³»æ–¹å¼**: ${contact}",
    },
  },
  "zh-tw": {
    status: {
      success: "âœ… ç°½åˆ°æˆåŠŸ",
      partial: "âš ï¸ éƒ¨åˆ†æˆåŠŸ",
      failed: "âŒ ç°½åˆ°å¤±æ•—",
      error: "ğŸ”¥ ç³»çµ±éŒ¯èª¤",
    },
    titles: {
      checkin_results: "ç°½åˆ°çµæœ (ç”¨æˆ¶æ•¸: ${count})",
      plugin_info: "ğŸ”Œ æ’ä»¶ä¿¡æ¯",
      execution_time: "â±ï¸ åŸ·è¡Œè€—æ™‚",
      error_details: "éŒ¯èª¤è©³æƒ…",
      retry_advice: "æ•…éšœæ’æŸ¥å»ºè­°",
    },
    messages: {
      already_claimed: "é‡è¤‡ç°½åˆ°",
      cookie_expired: "Cookie å¤±æ•ˆ",
      activity_ended: "æ´»å‹•å·²çµæŸ",
    },
    info: {
      plugin_name: "**æ’ä»¶åç¨±**: ${name}",
      plugin_version: "**æ’ä»¶ç‰ˆæœ¬**: ${version}",
      plugin_date: "**æœ€å¾Œæ›´æ–°æ—¥æœŸ**: ${date}",
      plugin_author: "**æ’ä»¶ä½œè€…**: ${author}",
      plugin_contact: "**è¯ç¹«æ–¹å¼**: ${contact}",
    },
  },
  ja: {
    status: {
      success: "âœ… æˆåŠŸ",
      partial: "âš ï¸ ä¸€éƒ¨æˆåŠŸ",
      failed: "âŒ å¤±æ•—",
      error: " ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼",
    },
    titles: {
      checkin_results: "ãƒã‚§ãƒƒã‚¯ã‚¤ãƒ³çµæœ (ãƒ¦ãƒ¼ã‚¶ãƒ¼æ•°: ${count})",
      plugin_info: " ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æƒ…å ±",
      execution_time: "â±ï¸ å®Ÿè¡Œæ™‚é–“",
      error_details: "ã‚¨ãƒ©ãƒ¼è©³ç´°",
      retry_advice: "ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã®ã‚¢ãƒ‰ãƒã‚¤ã‚¹",
    },
    messages: {
      already_claimed: "ã™ã§ã«å—ã‘å–ã‚Šæ¸ˆã¿ã§ã™",
      cookie_expired: "Cookie ãŒæœŸé™åˆ‡ã‚Œã§ã™",
      activity_ended: "ã‚¤ãƒ™ãƒ³ãƒˆã¯çµ‚äº†ã—ã¾ã—ãŸ",
    },
    info: {
      plugin_name: "**åå‰**: ${name}",
      plugin_version: "**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: ${version}",
      plugin_date: "**æœ€çµ‚æ›´æ–°æ—¥**: ${date}",
      plugin_author: "**ä½œè€…**: ${author}",
      plugin_contact: "**é€£çµ¡å…ˆ**: ${contact}",
    },
  },
  ko: {
    status: {
      success: "âœ… ì„±ê³µ",
      partial: "âš ï¸ ë¶€ë¶„ ì„±ê³µ",
      failed: "âŒ ì‹¤íŒ¨",
      error: "ğŸ”¥ ì‹œìŠ¤í…œ ì˜¤ë¥˜",
    },
    titles: {
      checkin_results: "ì²´í¬ì¸ ê²°ê³¼ (ì‚¬ìš©ì ìˆ˜: ${count})",
      plugin_info: "ğŸ”Œ í”ŒëŸ¬ê·¸ì¸ ì •ë³´",
      execution_time: "â±ï¸ ì‹¤í–‰ ì‹œê°„",
      error_details: "ì˜¤ë¥˜ ìƒì„¸ ì •ë³´",
      retry_advice: "ë¬¸ì œ í•´ê²° ì¡°ì–¸",
    },
    messages: {
      already_claimed: "ì´ë¯¸ ì‹ ì²­ ì™„ë£Œ",
      cookie_expired: "ì¿ í‚¤ ë§Œë£Œ",
      activity_ended: "ì´ë²¤íŠ¸ ì¢…ë£Œ",
    },
    info: {
      plugin_name: "**ì´ë¦„**: ${name}",
      plugin_version: "**ë²„ì „**: ${version}",
      plugin_date: "**ìµœì¢… ì—…ë°ì´íŠ¸**: ${date}",
      plugin_author: "**ì‘ì„±ì**: ${author}",
      plugin_contact: "**ì—°ë½ì²˜**: ${contact}",
    },
  },
};

function mergeHookConfig(options, hookType) {
  const baseConfig = { ...options };
  delete baseConfig.postCheckin;
  delete baseConfig.onError;

  return {
    ...baseConfig,
    ...(options[hookType] || {}),
  };
}

export async function postCheckin(options, ctx) {
  const mergedConfig = mergeHookConfig(options, "postCheckin");
  const { webhook, language = "en", mentionUsers } = mergedConfig;

  if (!webhook) return;

  const t = createTranslator(language);
  const embed = buildEmbed(ctx, t);

  console.log("discord-notify:", ctx);
  const tag_filter = options["tag_filter"] || [0];
  let mentionString = "";
  if (getResultCountByRetcode(ctx.result, tag_filter) < ctx.result.length) {
    mentionString = buildMentionString(mentionUsers);
  }

  await sendNotification(webhook, {
    content: mentionString,
    embeds: [embed],
  });
}

export async function onError(options, ctx) {
  const mergedConfig = mergeHookConfig(options, "onError");
  const { webhook, language = "en", mentionUsers } = mergedConfig;

  if (!webhook) return;

  const t = createTranslator(language);
  const embed = buildErrorEmbed(ctx, t);

  await sendNotification(webhook, {
    content: buildMentionString(mentionUsers),
    embeds: [embed],
  });
}

function createTranslator(lang) {
  const locale = i18n[lang] || i18n.en;
  return (key, vars) => {
    let template = key.split(".").reduce((obj, k) => obj?.[k], locale);
    return template?.replace(/\${(\w+)}/g, (_, v) => vars?.[v] ?? "");
  };
}

function buildMentionString(users = []) {
  return users.map((id) => `<@${id}>`).join(" ");
}

function constructPluginInfo(fields = [name, author, date], meta, t) {
  let values = [];
  for (let field of fields) {
    let value = meta[field]
      ? t(`info.plugin_${field}`, { [field]: meta[field] })
      : "";
    values.push(value);
  }
  return values.filter((v) => v.length > 0).join("\n");
}

function buildEmbed(ctx, t) {
  const { result, timestamp, plugins_meta } = ctx;
  const executionTime = Date.now() - timestamp;

  let fields_option = ctx.fields || [
    "plugin_info",
    "execution_time",
    "checkin_results",
  ];

  let discord_fields = {
    plugin_info: {
      name: t("titles.plugin_info"),
      value: constructPluginInfo(["name", "author", "date"], plugins_meta, t),
      inline: true,
    },
    execution_time: {
      name: t("titles.execution_time"),
      value: `${executionTime}ms`,
      inline: true,
    },
    checkin_results: {
      name: t("titles.checkin_results", { count: result.length }),
      value: formatResults(result, t),
      inline: false,
    },
  };

  let embed_fields = fields_option.map((field) => discord_fields[field]);

  return {
    title: getResultTitle(result, t),
    color: getStatusColor(result),
    fields: embed_fields,
    timestamp: new Date().toISOString(),
  };
}

function buildErrorEmbed(ctx, t) {
  const { error, timestamp } = ctx;

  return {
    title: t("status.error"),
    color: 0xff0000,
    fields: [
      {
        name: t("titles.error_details"),
        value: `\`\`\`${error.stack || error.message}\`\`\``,
      },
      {
        name: t("titles.retry_advice"),
        value: [
          "â€¢ " + t("messages.cookie_expired"),
          "â€¢ " + t("messages.activity_ended"),
          "â€¢ Check network connection",
        ].join("\n"),
        inline: true,
      },
    ],
    timestamp: new Date().toISOString(),
  };
}

function getResultCountByRetcode(results, retcode) {
  return results.filter((r) => retcode.includes(r.retcode)).length;
}

function getResultTitle(results, t) {
  const successCount = results.filter((r) => r.retcode === 0).length;

  if (successCount === results.length) return t("status.success");
  if (successCount > 0) return t("status.partial");
  return t("status.failed");
}

function getStatusColor(results) {
  const successCount = results.filter((r) => r.retcode === 0).length;
  if (successCount === results.length) return 0x00ff00; // green when all success
  if (successCount > 0) return 0xffa500; // orange when partial success
  return 0xff0000; // red when all failed
}

function formatResults(results, t) {
  return results
    .map((res, index) => {
      const status = getResultStatus(res, t);
      return `**User ${index + 1}**: ${status}\n\`\`\`${JSON.stringify(
        res,
        null,
        2
      )}\`\`\``;
    })
    .join("\n\n");
}

function getResultStatus(res, t) {
  switch (res.retcode) {
    case 0:
      return t("status.success");
    case -5003:
      return t("messages.already_claimed");
    case -100:
      return t("messages.cookie_expired");
    case -500012:
      return t("messages.activity_ended");
    default:
      return t("status.failed");
  }
}

async function sendNotification(webhook, payload) {
  try {
    const response = await fetch(webhook, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      console.error("Discord API Error:", await response.text());
    }
  } catch (error) {
    console.error("Failed to send Discord notification:", error);
  }
}
